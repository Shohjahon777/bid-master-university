generator client {
  provider = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-1.0.x"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id            String         @id @default(cuid())
  email         String         @unique
  name          String
  avatar        String?
  university    String?
  verified      Boolean        @default(false)
  role          UserRole       @default(USER)
  status        UserStatus     @default(ACTIVE)
  suspendedAt   DateTime?
  suspendedUntil DateTime?
  suspendedReason String?
  bannedAt      DateTime?
  bannedUntil   DateTime?
  bannedReason  String?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  auctions      Auction[]
  wonAuctions   Auction[]      @relation("AuctionWinner")
  bids          Bid[]
  notifications Notification[]
  watchlist     Watchlist[]
  conversations ConversationParticipant[]
  sentMessages  Message[]
  reports       Report[]       @relation("ReportReporter")
  reportedItems Report[]       @relation("ReportTarget")

  @@index([role])
  @@index([status])
  @@map("users")
}

model Auction {
  id            String        @id @default(cuid())
  title         String
  description   String
  category      String
  condition     String
  images        String[]      @default([])
  startingPrice Decimal       @db.Decimal(10, 2)
  currentPrice  Decimal       @db.Decimal(10, 2)
  buyNowPrice   Decimal?      @db.Decimal(10, 2)
  startTime     DateTime
  endTime       DateTime
  status        AuctionStatus @default(ACTIVE)
  winnerId      String?
  userId        String
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  winner        User?         @relation("AuctionWinner", fields: [winnerId], references: [id])
  bids          Bid[]
  watchlist     Watchlist[]

  // Single field indexes
  @@index([status])
  @@index([endTime])
  @@index([category])
  @@index([userId])
  @@index([createdAt])
  @@index([currentPrice])
  @@index([condition])
  // Composite indexes for common query patterns
  @@index([status, endTime])
  @@index([status, category])
  @@index([status, createdAt])
  @@index([category, status, endTime])
  @@map("auctions")
}

model Bid {
  id        String   @id @default(cuid())
  amount    Decimal  @db.Decimal(10, 2)
  userId    String
  auctionId String
  createdAt DateTime @default(now())
  auction   Auction  @relation(fields: [auctionId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([auctionId])
  @@index([userId])
  @@index([createdAt])
  @@map("bids")
}

model Notification {
  id        String           @id @default(cuid())
  type      NotificationType
  message   String
  read      Boolean          @default(false)
  link      String?
  userId    String
  createdAt DateTime         @default(now())
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([read])
  @@index([createdAt])
  @@map("notifications")
}

enum AuctionStatus {
  ACTIVE
  ENDED
  CANCELLED
}

model Watchlist {
  id        String   @id @default(cuid())
  userId    String
  auctionId String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  auction   Auction  @relation(fields: [auctionId], references: [id], onDelete: Cascade)

  @@unique([userId, auctionId])
  @@index([userId])
  @@index([auctionId])
  @@map("watchlist")
}

model Conversation {
  id           String                    @id @default(cuid())
  lastMessageAt DateTime?
  createdAt    DateTime                  @default(now())
  updatedAt    DateTime                  @updatedAt
  participants ConversationParticipant[]
  messages     Message[]

  @@index([lastMessageAt])
  @@map("conversations")
}

model ConversationParticipant {
  id             String       @id @default(cuid())
  userId         String
  conversationId String
  createdAt      DateTime     @default(now())
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@unique([userId, conversationId])
  @@index([userId])
  @@index([conversationId])
  @@map("conversation_participants")
}

model Message {
  id             String       @id @default(cuid())
  content        String       @db.Text
  senderId       String
  conversationId String
  read           Boolean      @default(false)
  createdAt      DateTime     @default(now())
  sender         User         @relation(fields: [senderId], references: [id], onDelete: Cascade)
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([senderId])
  @@index([createdAt])
  @@index([read])
  @@map("messages")
}

enum NotificationType {
  BID_PLACED
  BID_OUTBID
  AUCTION_WON
  AUCTION_ENDED
  AUCTION_CANCELLED
  AUCTION_CREATED
  MESSAGE
}

enum UserRole {
  USER
  ADMIN
}

enum UserStatus {
  ACTIVE
  SUSPENDED
  BANNED
}

model Report {
  id          String       @id @default(cuid())
  type        ReportType
  targetId    String
  reporterId  String
  reason      String
  description String?      @db.Text
  status      ReportStatus @default(PENDING)
  resolvedAt  DateTime?
  resolvedBy  String?
  action      String?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  reporter    User         @relation("ReportReporter", fields: [reporterId], references: [id], onDelete: Cascade)
  target      User         @relation("ReportTarget", fields: [targetId], references: [id], onDelete: Cascade)

  @@index([status])
  @@index([type])
  @@index([targetId])
  @@index([reporterId])
  @@index([createdAt])
  @@map("reports")
}

enum ReportType {
  AUCTION
  USER
  MESSAGE
}

enum ReportStatus {
  PENDING
  REVIEWED
  RESOLVED
}

model EmailLog {
  id          String   @id @default(cuid())
  to          String
  subject     String
  type        String
  status      EmailStatus @default(PENDING)
  error       String?
  sentAt      DateTime?
  createdAt   DateTime   @default(now())
  userId      String?

  @@index([userId])
  @@index([status])
  @@index([type])
  @@index([createdAt])
  @@map("email_logs")
}

enum EmailStatus {
  PENDING
  SENT
  FAILED
}
